[TOC]



# Nginx

## Nginx介绍

Nginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，有报告表明能支持高达 50,000 个并发连接数。

## 正向代理与反向代理

正向代理：需要在客户端配置代理服务器进行指定网站访问

![image-20211017110712374](C:\Users\Wang\OneDrive\Java全家桶\Nginx.assets\image-20211017110712374.png)

反向代理：暴露的是代理服务器地址，隐藏了真实服务器的IP地址。

## 负载均衡

增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器

## 动静分离

![image-20210828161442457](C:\Users\Wang\AppData\Roaming\Typora\typora-user-images\image-20210828161442457.png)

两种实现

1.纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案

2.动态跟静态文件混合在一起发布，通过 nginx 来分开

## 配置文件

包含三部分内容
1 ）全局块：配置服务器整体运行的配置指令
比如 worker_processes 1; 处理并发数的配置

2 events 块 ：影响 Nginx 服务器与用户的网络连接
比如 worker_connections 1024; 支持的最大连接数为 1024

3 http 块:
http 全局块
server 块

## 负载均衡服务器分配策略



1、轮询

默认策略，每个请求按时间顺序逐⼀分配到不同的服务器，如果某⼀个服务器下线，能⾃动剔除

2、weight

weight代表权重，默认每⼀个负载的服务器都为1，权重越⾼那么被分配的请求越多（⽤于服务器性能不均衡的场景）

3、ip_hash

每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如：

4、fair（第三方）	

按后端服务器的响应时间来分配请求，响应时间短的优先分配。

## Nginx原理

![image-20210828181147731](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20210828181147731.png)

Master进程的作用主要是管理worker进程，⽐如：

接收外界信号向各worker进程发送信号(./nginx -s reload)
监控worker进程的运⾏状态，当worker进程异常退出后Master进程会⾃动重新启动新的worker进程等

worker进程:

worker进程具体处理⽹络请求。多个worker进程之间是对等的，他们同等竞争来⾃客户端的请求，各进程互相之间是独⽴的。⼀个请求，只可能在⼀个worker进程中处理，⼀个worker进程，不可能处理其它进程的请求。

worker进程的个数是可以设置的，⼀般设置与机器cpu核数⼀致。



## 一个 master 和多个 woker 的好处

每个worker进程都是独⽴的，不需要加锁，节省开销, ⼀个异常结束，其他的照样能提供服务
多进程模型为reload热部署机制提供了⽀撑



# Redis

## Redis理论

解决了关系型数据库性能瓶颈和扩展瓶颈，性能瓶颈：磁盘IO性能低下，扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群。Nosql解决这种问题,降低磁盘IO次数，去除数据间关系。

## Redis五大数据分析

String: 储存单个数据 key-value 

使用场景：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性



Hash: key value(field1 value1, field2 value2 ...)  hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）

使用场景：购物车redis设计，field是商品代码，value是数量

String使用json存储数据，更适合数据读取，因为所有数据需要一次性保存，输出, Hash存储数据适合数据修改



List: key value1 [value2]    保存多个数据，底层使用双向链表存储结构实现

场景：微信朋友圈点赞



Set:  key member1 [member2]   与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的

使用场景 ：公司对旗下新的网站做推广，统计网站的PV（访问量）,UV（独立访客）,IP（独立IP）



Sorted_set: 在set的存储结构基础上添加可排序字段 zadd key score1 member1 [score2 member2]

业务场景: 复杂权限排名

如：xxyy xx代表国内国际订单，国际订单优先，yy代表订单数量，yy越小越优先

假设 a: 0013 b:1331 需要注意a需要在13之前加0来补充数据长度。



## Redis数据库数量以及切换

```shell
//切换数据库
select index
//基本操作
quit
ping
echo message
//数据移动
move key db
```

## RDB

RDB：保存数据快照，存储格式简单，关注点在数据

save的时候会阻塞线程直到持久化结束。

bgsave：启动新线程在后台执行

![image-20211022124010166](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022124010166.png)

自动启动save：save second changes   满足限定时间范围内key的变化数量达到指定数量即进行持久化

优点：

RDB是一个紧凑压缩的二进制文件，存储效率较高
RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景
RDB恢复数据的速度要比AOF快很多
应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。

缺点：

RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据
bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能
Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象

## AOF

AOF：存储的是日志形式，存储格式复杂，关注点在操作

以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。

三种策略：

always：每次写入操作均同步，零误差，性能差	

everysec：每秒记录一次，准确性高，性能高，会损失最后一秒的数据	

no：系统控制，过程不可控

AOF重写：对于通一个指令的若干个修改指令，只保存最后一次修改的结果。降低磁盘占用率，提高磁盘利用率。提高持久化效率，降低写时间。提高数据恢复时候的效率。

![image-20211022130442261](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022130442261.png)

重写规则：

1. 进程内已超时的数据不再写入文件
2. 忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令
3. 对同一数据的多条写命令合并为一条命令

![image-20211022125522024](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022125522024.png)

## AOF vs RDB

RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊
如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF
如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB
灾难恢复选用RDB
双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量

## 事务

```
multi //开始事务
common 1
common 2
common 3
exec //执行事务
```

如果命令输入格式错误，全部不执行。

如果结果错误，会执行结果正确的。

## 锁

watch key1 key2 ...	当执行事务之前key发生了改变就终止事务	 unwatch解除



公共锁/分布式锁 setnx lock-key value

如果锁上了，就是操作成功拿到锁了，拥有控制权，如果失败，就需要排队等待。

使用结束之后使用del操作释放锁



死锁：上锁的时候当机了怎么办

expire lock-key second pexpire lock-key milliseconds	设置锁的过期时间。



## 删除策略

TLL获取数据状态

XX： 具有时效性的数据

-1：永久有效的数据

-2：已经过期的数据或者被删除的数据或没有被定义的数据

## 定时删除，惰性删除，定期删除

定时删除：创建一个定时器，当过期时间到达时，由定时器任务立即执行对键的删除操作

优点：节省内存，快速释放内存资源

缺点：CPU压力大



惰性删除：下次访问数据的时候，如果过期了再删除

优点：节约CPU性能

缺点：内存压力大，有的数据很久都不会删除



定期删除：读取配置server.hz的值，每秒执行hz次轮训：

没次轮询遍历所有数据库，随机挑选W个key，删除其中过期的。

如果删除的key大于W*0.25再次删除，如果key小于W * 0.25 则进行下一个。



三种对比：定时删除通过 CPU时间换内存空间，惰性删除用内存空间换CPU时间，最后一种定期删除每秒花费固定的CPU资源维护内存，对垃圾多的数据库定点抽查。

## 逐出算法

新数据加入发现redis内存不够就会使用逐出算法。

![image-20211022154317322](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022154317322.png)

## bitmaps,HyperLogLog, GEO

Bitmaps:直接操作二进制数据

![image-20211022161301651](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022161301651.png)



HyperLogLog:用来统计集合里数据的数量

估算算法，不完全准确，速度非常非常快

![image-20211022161722699](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022161722699.png)



GEO:保存GPS定位信息

## 主从复制

redis集群：一个master 多个slave

作用： 读写分离，负载均衡，故障恢复，数据冗余



三个阶段：

建立连接阶段 : 建立slave到master的连接，使master能够识别slave，并保存slave端口号
数据同步阶段:

slave初次连接master后，复制master中的所有数据到slave
将slave的数据库状态更新成master当前的数据库状态 (使用RDB文件)

命令传播阶段

Master将收到的数据变更命令发送给slave



复制缓冲区：是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区。

复制缓冲区由两个值组成：偏移量和字节值。 Slave记录offset（偏移量），master需要记录自己已经发送的offset，slave记录已接收的信息对应的offset。

 

心跳机制

slave不停地ping master判断延迟。



常见问题：

频繁的全量复制：

1. master重启后runid变化，导致全部slave进行全量复制。 解决方案：master内部创建master_replid变量，在关闭时进行RDB持久化，将runid和offset保存到RDB文件中。

2. 网络环境不佳，出现网络中断，slave不提供服务，断网后offset越界出发全量复制。 解决方案：修改缓冲区大小

## 哨兵模式

不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测

三个阶段： 

1. 监控阶段

2. 通知阶段 (半数以上sentinel认为master断了就认为master死了)

3. 故障转移阶段

   

   ![image-20211022172705974](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022172705974.png)

然后发送指令，告诉master他是新的master，告诉slave新的master的ip



## 集群

集群设计：

通过算法设计，计算出key应该保存的位置
将所有的存储空间计划切割成16384份，每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间
将key按照计算出的结果放到对应的存储空间

## 缓存预热

问题：服务器启动之后光速宕机

问题排查：请求数量较高，主从之间数据吞吐量较大

![image-20211022183427167](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022183427167.png)

## 缓存雪崩

缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%）。

```
1.系统平稳运行过程中，忽然数据库连接量激增
2.应用服务器无法及时处理请求
3.大量408，500错误页面出现
4.客户反复刷新页面获取数据
5.数据库崩溃
6.应用服务器崩溃
7.重启应用服务器无效
8.Redis服务器崩溃
9.Redis集群崩溃
10.重启数据库后再次被瞬间流量放倒
```

```
1.在一个较短的时间内，缓存中较多的key集中过期
2.此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据
3.数据库同时接收到大量的请求无法及时处理
4.Redis大量请求被积压，开始出现超时现象
5.数据库流量激增，数据库崩溃
6.重启后仍然面对缓存中无数据可用
7.Redis服务器资源被严重占用，Redis服务器崩溃
8.Redis集群呈现崩塌，集群瓦解
9.应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃
10.应用服务器，redis，数据库全部重启，效果不理想
```

问题：短时间内大量key集中过期

解决方案：

```
1.更多的页面静态化处理
2.构建多级缓存架构 Nginx缓存+redis缓存+ehcache缓存
3.检测Mysql严重耗时业务进行优化 对数据库的瓶颈排查：例如超时查询、耗时较高事务等
4.灾难预警机制 监控redis服务器性能指标
    CPU占用、CPU使用率
    内存容量
    查询平均响应时间
    线程数
5.限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问
```

1.LRU与LFU切换
2.数据有效期策略调整
	根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟
	过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量
3.超热数据使用永久key
4.定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时
5.加锁 慎用！

## 缓存击穿

缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。

```
1.预先设定 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势
2.现场调整 监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key
3.后台刷新数据 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失
4.二级缓存 设置不同的失效时间，保障不会被同时淘汰就行
5.加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！
```



## 缓存穿透

1.Redis中大面积出现未命中	2.出现非正常URL访问

获取的数据在数据库中也不存在,是黑客攻击

解决方案：

```
1.缓存null 对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟
2.白名单策略
提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）
使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）
3.实施监控 实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比
非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象
活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）
4.key加密 问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问
```



## 布隆过滤器

**布隆过滤器可以判断某个数据一定不存在，但是无法判断一定存在**。

使用一个2进制数组，对进来的数据进行hash，计算出数字然后把全是0的bitmap对应位置改成1，查询的时候，如果计算结果是1代表存在，0的代表不存在。



## 跳表

Redis的Sorted_set使用的是跳表，类似红黑树，结构更加简单。可以快速找到对应的值



## 常见面试题

### Redis集群原理

1. 使用了一致性hash算法快速找到数据的分片。

   一致性hash算法：对2^32去模，将hash值空间组织成虚拟的圆环。

2. 将主机的ip或者名字进行hash计算出hash值

   ![image-20211025154624714](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025154624714.png)

3. 让数据使用和上面相同的hash函数，计算出数据存储的服务器

   ![image-20211025154728121](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025154728121.png)

这么做的好处是就算服务器宕机了，也能继续运行。

4. 如果增加了一台服务器，也只需要改变少量数据，而不是全部数据

问题：数据倾斜：

![image-20211025154955542](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025154955542.png)

解决方法：

![image-20211025154938000](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025154938000.png)



### Redis分布式锁

分布式锁需要解决的4大问题：

1. 互斥性：只有一个客户端获取锁
2. 安全性：只能背持有锁的客户端删除锁
3. 死锁：当服务死机之后，应该有机制放置客户端长时间占用锁
4. 容错：当服务关闭之后应该有办法任然可以获取放置锁

expire key second + SETNX key value: 如果key不存在，则创建并且赋值 +设置过期时间，时间过了就删除.

问题：原子性不满足，万一在创建key之后设置过期时间之前死机了就不满足原子性了

解决方案： NX代表如果不存在才设置，XX表示不管。

![image-20211025155808708](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025155808708.png)

防止大量key同时过期，在key存活时间上加随机值

其他解决方案：blpop 会

### 如何用redis做出异步队列（消息队列）

使用list就可以了，用rpush和lpop，缺点是没有等待，队列里有值就直接消费，解决方法是使用sleep机制去调用LPOP。

更好的解决方法：

![image-20211025160311466](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025160311466.png)

更好的办法：使用主题订阅者模式 pub/sub, 但是消费的发布是无状态的，无法保证消息可达。



### Redis持久化

BGSAVE原理

![image-20211025160837808](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025160837808.png)

![image-20211025160936943](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025160936943.png)

RDB都是全量同步，所以很慢

AOF日志重写也使用了Copy -on-Write

![image-20211025161912564](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025161912564.png)

RDB缺点：不能增量处理

AOF缺点：文件太大

混合模式：使用BGSAVE做全量持久化同时使用AOF做增量持久化，在进行BGSAVE的时候，后面新的数据就使用AOF保存。



### Redis Pipeline

Pipeline和Linux的管道类似，Redis基于请求，响应模型，单个请求处理需要一一答应。

Pipeline执行批量指令，节省应答开销.



### 主从复制

全量复制 第一次用的是RDB

![image-20211025163027393](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025163027393.png)

增量同步：使用AOF



哨兵模式保证主从服务器的可用性，哨兵使用流言协议

![image-20211025163320336](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025163320336.png)



### 从海量数据里查询固定前缀的key

方法1. Keys pattern: 找到所有符合给定模式的pattern的key

缺点：一次返回所有匹配的key，消耗比较大

方法2 SCAN cursor [MATCH pattern] [Count count]

基于游标的迭代器，以0作为游标进行迭代，不保证每次执行都返回某个给定数量的元素,大概率符合count参数,而且可能会出现重复数据，对于大量数据（超过百万）可以使用。

# RabbitMQ

## 为什么要使用RabbitMQ

本质是个队列，FIFO，队列中存放message。

1. 流量消峰:使用消息队列做缓冲，把一秒内下的订单分散成一段时间来处理
2. 应用解耦:不同微服务之间的通信如果使用消息中间件，如果某个服务死机重启，别的服务传来的消息可以存储在消息队列里等待服务重启完毕
3. 异步处理:服务异步调用，解决调用的时候的消息传输问题，不需要主动监听，等待消息队列发消息就可以了。

## 核心概念：生产者，消费者，队列，交换机

生产者：产生数据发送消息的程序

消费者；等待接受消息的程序

队列：消息被存储在队列中，队列是FIFO的。

交换机:在生产者和队列之间，用来发送消息到正确的队列里。

Connection: 生产者，消费者和broker（RabbitMQ Server)之前的TCP连接。

Channel: 每个连接一个cahnnel，代表着一个线程的连接，是一个轻量级的TCP连接。

Binding: Exchange和queue之间的虚拟连接。

## RabbitMQ的交换模式

1. Hello World:

   ![image-20211022212649457](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022212649457.png)

2. Work Queues

   ![image-20211022212709480](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022212709480.png)

   不公平分发：prefetch代表消费者可以处理的消息数量

   ![image-20211022215450983](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211022215450983.png)

   QOS预取值：指在queue里未确认消息的上线，超过这个数值就不会再向管道传送消息了,数值太高会导致消费者内存太大，太低会导致消费者效率太慢。

3. 交换机：直接，主题，标题，扇出

   直接：消息发送到指定的队列中去，如果两个队列设置的一样，就会变成广播

   扇出：广播消息到所有队列中

   主题：匹配模式

   ![image-20211023104242549](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211023104242549.png)



## 持久化，确保可靠性策略：

1. 消息应答：消费者在接收到消息并且处理该消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把该消息删除了。自动应答就是消息发送后就认为发送成功，这种情况默认消费者有足够的能力处理消息。 如果消费者由于某些原因失去连接，消息未发送ACK确认，RabbitMQ就会将未完成的消息重新排队。

2. 持久化：将队列和消息持久化

3. 发布确认：生产者将信道设置为confirm模式，一旦信道进入confirm模式，所有在该信道上的发布的消息都会被指派一个唯一的ID，broker就会发送确认给生产者，告诉生产者消息成功传入队列，支持异步进行的。有批量确认单个确认两种模式。

   ## 死信队列

   没有办法处理的消息会被放到死信队列：

   消息TTL过期
   队列达到最大长度(队列满了，无法再添加数据到mq中)
   消息被拒绝(basic.reject或basic.nack)并且requeue=false

## 延迟队列

用来存放需要在指定事件被处理的元素的队列。

使用场景：

1. 订单在十分钟之内未支付就取消
2. 用户注册成功后，三天没登录就进行短信提醒
3. 退款三天内没得到处理就告知相关运营人员



TTL属性:

可以给消息或者队列设置TTL，如果规定时间内没有被消费就会变成死信。

队列设置TTL：消息过期就被丢弃

消息设置TTL：在被发送前判断是否丢弃。

问题：RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。解饿决方案：RabbitMQ提供了相关的插件解决方案。



## 极端情况下的发布确认

在RabbitMQ重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复

通过设置mandatory参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。

备份交换机：用来接受到一条不可路由消息时，就会把这条消息转发到备份交换机中，优先级高于mandatory。



## 惰性队列

尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中,支持更长的队列，

## 镜像队列

将队列镜像到集群的其他及诶单上，集群中的一个节点失效了，可以自动切换到镜像中的另一个节点上。

# Java基础难点

## 数据类型

![image-20211024102934485](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211024102934485.png)



## 修饰符

Final

类：被修饰的类，不能被继承。
方法：被修饰的方法，不能被重写。
变量：被修饰的变量，不能被重新赋值。

![image-20211024105741084](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211024105741084.png)



# Linux指令

![image-20211025164526010](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025164526010.png)



```shell
cat xxx 查看文件内容
ls 查看文件目录
less xxx.sql 查看文件
more xxx.sql 查看文件
vi xxx.sql 编辑文件
vim xxx.sql 编辑文件

find -name path [option] params 查找指定文件
find ~ -name "target*" 模糊搜索
find / ~ -iname "target*" 忽略大小写并且全局查找

grep[options] pattern file  查找文件里符合条件的字符串
grep "moo" target*  //只会查找出指定的行，从头部是target开头的文件里找到包含moo的行

|管道操作符
将指令连接起来，前一个指令的输出就是后一个指令的输入

awk [options] 'cmd' file 一次读取一行文本，按输入分隔符进行切片，切成多个组成部分

sed -i 's/^Str/String' replace.java 替换文件内容 str替换成String


```

![image-20211025173527736](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025173527736.png)

![image-20211025173838038](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025173838038.png)

![image-20211025174016972](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025174016972.png)



![image-20211025174813465](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211025174813465.png)

/g代表对所有内容进行替换，不然只会替换这行的第一个。

/d表示删除行。

# JVM

![image-20211026114618215](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026114618215.png)

## 为什么JVM不直接将源码解析成机器码去执行

1. 每次执行都需要检查语法
2. 兼容性更好，scala也可以生成字节码文件让jvm运行 。

## JVM类加载 ClassLoader

![image-20211026155823821](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026155823821.png)

ClassLoader从jvm之外获得class文件的二进制数据流，装载进jvm系统。

![image-20211026152907086](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026152907086.png)

双亲委派机制：使用双亲委派机制的主要原因是:

避免多分同名class被加载，所以用户定义的String类，是不会被加载的

![image-20211026154121655](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026154121655.png)

类的加载方式：

隐式加载：new

显式加载：loadClass,forName

forname 和 loadClass的区别是：

Class.forName得到的class是已经初始化完成的

Classloder.loaderClass得到的class是还没有链接的

## java内存模型

![image-20211026114844790](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026114844790.png)

**程序计数器：**存储指向下一条指令的地址，也就是将要执行的指令代码。线程私有因为多线程任务时线程之间不停切换。 对于Native方法，计数器值为Undefined.

**Java虚拟机栈**：方法执行的内存模型，每个方法会创建一个栈帧，栈帧内存储局部变量，操作栈，动态链接，返回地址等

![image-20211026123426537](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026123426537.png)

![image-20211026123820335](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026123820335.png)

本地方法栈：类似，只是创建的方法是本地方法(native)。 

Metaspcae元空间：存储类加载信息

堆：存储数组和类对象

常量池：自面量，符号引用量

## 递归为什么会引起java OOM异常？

Java虚拟机栈：递归创建了太多的方法,创建栈帧太多了. StackOverflowError.

当虚拟机栈动态扩展，无法申请到更多的内存，就会发起OOM异常。



## 为什么有Metaspace区域

原来的perm区，叫做非堆(永久代)，非常容易出现OOM，所以使用Metaspace脱离jvm内存，直接使用系统内存来防止OOM的出现，主要存储类的信息，方法数据，方法代码。 常量池在java7之后储存在堆中。



## -Xms Xmx -Xss的含义

![image-20211026160904252](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026160904252.png)

## 字符串常量池

![image-20211026162545009](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026162545009.png)

当我们使用双引号创建一个字符串时，首先在字符串常量池中查找是否有相同值的字符串，如果发现则返回其引用，否则它会在池中创建一个新的字符串，然后返回新字符串的引用。

如果使用new运算符创建字符串，则会强制String类在堆空间中创建一个新的String对象。我们可以使用intern()方法将其放入字符串常量池或从字符串常量池中查找具有相同的值字符串对象并返回其引用



## 垃圾回收机制

判断垃圾的标准：没有被其他对象引用

判断方法：

1. 引用计数算法

   通过判断对象的引用数量来判断是否是垃圾

   每个对象实例都有一个引用计数器，被引用就会+1，完成引用就会-1

   优点：效率高	缺点：无法检测循环引用，到处内存泄露。

2. 可达性分析算法

   通过判断对象的引用链是否可达来决定对象是否可以被回收.

   ![image-20211026193716769](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026193716769.png)

   

## 常用算法

1. 标价清除算法

   ![image-20211026194116175](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026194116175.png)

- 标记：Collector从引用的根节点开始遍历，标记所有的被引用的对象，在对象的对象头中记录为可达对象

- 清除：将对象头中没有标记为可达对象的对象进行清除

  优点：常用简单

  缺点：效率不高，进行gc时候需要停止整个应用程序，会产生大量内存碎片。

2. 复制算法

   将活着的内存空间分为两块，每次使用一块，进行垃圾回收的时候，将存活对象复制到另一块未使用的区域，然后将源区域清空，然后交换两个内存的角色

   ![image-20211026194320701](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026194320701.png)

   优点：高效，没有内存碎片

   缺点：需要两倍内存，如果系统中的可用对象很多，复制算法不会很理想，因为要复制大量的对象

3. 标记压缩算法

   - 第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象.
   - 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。
   - 之后，清理边界外所有的空间。

   ![image-20211026194922199](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026194922199.png)

   优点：

   - 消除了标记一清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只 需要持有一个内存的起始地址即可。
   - 消除了复制算法当中，内存减半的高额代价。

   缺点：

   - 从效率.上来说，标记一整理算法要低于复制算法。
   - 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。
   - 移动过程中，需要全程暂停用户应用程序。即： STW

4. 分代收集算法：

   Minor GC：只清理年轻代

   伊甸区满了，就执行minorGC，垃圾处理，有用的放到幸存者1。

   第二次的时候，把伊甸区+幸存者1的垃圾清楚，所有的放到幸存者2。

   如果幸存者区放不下了，就放到老年区（默认15次以后）。

   **大对象直接去老年代**

   

   Full GC

   老年代空间不足

   Minor GC晋升到老年代的平均大小大于老年代的剩余空间。

   System.gc()；
   
   
   
5. 增量收集算法：每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，反复进行。

   缺点：虽然减少了系统停顿时间，但是线程之间的切换有损耗，使得垃圾回收的总体成本上升。

6. 分区算法：将整个堆空间划分成连续的不同小区间，每一个小区间都独立使用，独立回收。

## 常用垃圾收集算法

Safepoint:分析过程中对象引用关系不会变化的点，比如方法调用，循环跳转，异常跳转。

- 主动式中断： 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。

Safe Region:安全区域，一个范围内都是安全的区域，这段代码中对象的引用关系不会变化。



### 新生代垃圾收集器

Serial收集器：单线程收集器，进行垃圾收集时，必须暂停所有工作线程。

优点：简单高效，没有线程交互开销，对于小场景比较合适。

![image-20211026230725641](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026230725641.png)

ParNew回收期：Serial的多线程版本，单线程略差于Serial，多线程明显强

![image-20211026231017600](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026231017600.png)

Parallel回收器：目标是达到一个可控制的吞吐量,主要是通过设置最大停顿实现。

### 老年代垃圾收集器

Serial Old 和Serial一样，但是使用的不是复制算法而是标记整理算法.

Parallel Old收集器：和Parallel一样，但是使用标记整理算法。

CMS收集器：

![image-20211027103300886](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211027103300886.png)

1. 初始标记：Stop the world,寻找根节点以及和根节点紧密相连的节点
2. 并发标记：继续想下遍历对象
3. 并发预清理：检查前一阶段执行过程中，从年轻代进入老年代的对象
4. 重新标记：暂停虚拟机，扫描CMS堆中的剩余对象
5. 并发清理：清理垃圾
6. 重置：重置CMS收集器的数据结构。

缺点：产生内存碎片，对cpu资源敏感，无法处理浮动垃圾

G1收集器：

将整个java堆内存划分成多个大小相等的区域，年轻代老年代不再物理隔离，出发垃圾回收机制时候，只对部分区域进行回收，优先回收容量比较高的区域，并且每次最多回收一个设定好的时间。



## Object的finalize（）方法

对象被标记为垃圾之后，如果有finalize方法，会被放置于F-Queue队列，方法执行可能会被终止,类似复活甲给对象一次重生机会。

## 强引用，软引用，弱引用，虚引用

强引用：普通的引用，比如new一个对象就是强应用，GC不会回收。

软引用：处在有用但是并非必须的状态，当内存空间不足的时候，GC会回收。可以用来缓存之类的。

弱引用：非必须的对象，GC发现弱引用就会回收，适合偶尔使用并且不影响垃圾收集的对象。

虚引用：不会决定对象的生命周期，任何时候都可能会被垃圾收集器回收，必须和引用队列ReferenceQueue联合使用，他起到哨兵的作用。

# Spring

## IOC/AOP

控制反转的理解：自己写代码会从上层调用接口到下层，springIOC会从底层开始注入上层。

![image-20211026172359716](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211026172359716.png)

AOP的理解：将重复的代码单独保存，需要执行时候直接执行，可以关注业务逻辑

Cglib和JdkProxy



# 集合框架常考内容：



## 数组和链表的区别

![image-20211027153739628](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211027153739628.png)







## 链表的操作

## 队列，栈的应用

## 二叉树的遍历方式以及递归和非递归的实现

## 红黑树的旋转

## 排序

## 外部排序





# 多线程

## Thread中的run和star方法的区别

star方法会调用native方法创建一个新的子线程并启动，run方法只是thread的一个普通方法。



## Thread和Runnable的区别

Runnable编写的时候和Thread基本一样，Runnable是实现接口Thread是继承runnable必须创建thread然后把runnable作为参数引用才能运行。Thread是实现了Runnable接口的类，使得run支持多线程，因为单一继承原则，推荐使用runnable.

## 如何实现处理线程的返回值

1. 主线程等待法

   ![image-20211028123227323](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028123227323.png)

2. 使用Thread类的join方法：父线程等待子线程运行结束才继续

3. 使用Callable接口：使用FutureTask or 线程池 

   ![image-20211028124054752](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028124054752.png)

   ![image-20211028124127214](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028124127214.png)

   线程池：

   ![image-20211028124437085](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028124437085.png)

## 线程的状态

新建：创建后没有运行的状态

运行：包含running和ready

无限等待等待：Object.wait()	Thread.join()	LockSupport.park() 会造成线程被其他线程唤醒之前无限等待。

限期等待：Thread.sleep();	Object.wait(time), Thread.join(xxx), LockSupport.parkNanos(), LockSupport.parkUntil()

阻塞：等待获取排它锁

结束：已终止线程的状态，线程已经结束执行



![image-20211028153426263](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028153426263.png)

## Sleep和wait的区别

Sleep只会让出CPU，不会导致锁行为的改变，wait只能在synchronized中使用，不仅让出CPU，还会释放已经占有的同步资源锁

## notify和notifyAll

notifyAll会让等待池内所有线程全部进入锁池中，notify只会随机挑选一个等待池里的线程进入锁池去竞争获取锁的机会。

wait会让对象进入等待池，等待池的线程不会去争抢锁。

## yield

Thread.yield被调用的时候，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示,并且yield不会让出锁。

## 中断线程

Thread.interrupt()通知线程应该被中断了 不能强制中断，只是通知

![image-20211028153041198](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028153041198.png)



## Synchronized

### 特性：

互斥性:保证原子操作

可见性：锁被释放之前，对共享变量所做的修改对于另一个线程是可见的。

对象锁和类锁：

![image-20211028163854059](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028163854059.png)

### 实现原理：

java对象头中有一个monitor对象，这就是对象锁,如果有程序获取了，就会变成1，释放之后变回0。

可重入性：锁里面的锁可以被获取。

自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让进程执行循环等待锁的释放，不让出CPU，但是如果锁占用时间太长就占用太多的CPU资源。

适应自旋锁：自旋的次数不再固定，根据前一个锁上的自旋时间以及锁的拥有者的状态来决定。

锁消除：编译的时候对上下文进行扫描，取出不可能存在竞争的锁

![image-20211028170036996](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028170036996.png)

这种情况下StringBuffer内的锁会被消除。

锁粗化：通过扩大加锁的范围避免反复加锁和解锁

![image-20211028170259478](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028170259478.png)

会给锁加入到外部，这样一个锁可以执行所有的100次append操作。



### 四种状态

无锁

偏向锁：一个线程获得过锁，会有记录，再次获得所相同锁的时候就不需要进行cas操作（同步操作），只要检查是不是相同线程就可以了。

轻量级锁：当第二个进程进入的时候就会升级为轻量级锁，适用于线程交替执行同步块的情况，程序会进入自选状态

重量级锁：自旋失败就会省纪委重量级锁，线程会直接阻塞



### 锁对于内存的含义：

![image-20211028171449085](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028171449085.png)

### Synchronized和ReentrantLock的区别

ReentrantLock基于AQS实现，可以实现比Synchronized更加细粒度的控制，调用lock之后必须使用unlock释放锁，

![image-20211028171933581](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028171933581.png)



## JMM

JMM是抽象概念，并不真实存在，描述的是一组规范，通过规范定义了程序中各个变量的访问方式。

![image-20211029103007159](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029103007159.png)

工作内存（本地内存）存储的是对主内存变量信息的拷贝，本地变量对其他线程不可见。   

### JMM和java内存区域划分

JMM描述的是一组规则，围绕原子性，有序性与可见性展开。

相似点：都存在内存共享区域和私有区域

基本数据类型都会存储在栈帧中，对象实例都会存储在主内存中，只在栈帧中存储引用。 Static变量，成员变量，类信息会存储在主内存中

### 数据可见性问题

A操作的结果需要对B操作可见，则A与B存在happens-before关系

### Happens-before

![image-20211029113006186](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029113006186.png)



### volatile

jvm提供的轻量级同步机制

保证volatile修饰的共享变量对所有线程总是可见的

禁止指令重排序优化

使用要求：对象操作需要本身就有原子性，++就属于没有原子性，修改Ture和false就是有原子性的操作。

实现原理：

![image-20211029115212345](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029115212345.png)

实现禁止重拍优化：

![image-20211029115255113](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029115255113.png)

重排序优化造成的潜在危险： 解决方法: 给instance变量添加volatile 

![image-20211029115652097](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029115652097.png)



![image-20211029115748511](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029115748511.png)

## 线程池

线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，只有在等待队列满了以后才会创建新的线程，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。

线程池都是调用同一个方法，只是参数不一样，最后都是实现Excutor这个接口。

![image-20211029131032028](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029131032028.png)

一般使用ThreadPoolExecutor

参数：

• corePoolSize线程池的常驻线程数
• maximumPoolSize能容纳的最大线程数
• keepAliveTime空闲线程存活时间
• unit 存活的时间单位
• workQueue 存放提交但未执行任务的队列
• threadFactory 创建线程的工厂类
• handler 等待队列满后的拒绝策略

![image-20211029131431066](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029131431066.png)

![image-20211029131641321](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029131641321.png)

![image-20211029131811281](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211029131811281.png)

线程池大小如何决定：

CPU密集型：核心数或者核心数+1

I/O密集型：CPU核心数*（1+平均等待时长/平均工作时长）

![image-20211105135236398](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211105135236398.png)

## CAS

乐观锁：在提交数据的时候如果发现数据被改变了，重新提交

![image-20211028173058448](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028173058448.png)

![image-20211028173002857](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211028173002857.png)

ABA问题：如果一开始是A后面被改成了B，然后又被改回来了，CAS是不知道的。

## ThreadLocal

如果你创建了⼀个ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal 变量名的由来。他们可以使⽤ get􀀄􀀅 和 set􀀄􀀅 ⽅法来获取默认值
或将其值更改为当前线程所存的副本的值，从⽽避免了线程安全问题。



## 线程启动方法

1. 实现Runnable接口并且传入Thread类

2. 继承Thread类重写run（）

   最后都是调用start方法来创建新线程。

   实现Runnable接口更好，因为使用继承Thread类，每次新建一个任务只能新建一个独立的线程，使用Runnable和线程池可以大大减小这样的损耗

   继承Thread类以后，由于java语言不支持双继承，就无法再继承其他类了。



## 死锁

![image-20211105125122409](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211105125122409.png)

# mysql

## 索引

### 为什么要使用索引

如果没有索引就会使用全表扫描，所有数据都会放到内存里，进行寻找，只适合数据量非常少的情况。索引解决了这个问题

### 什么样的信息可以成为索引

主键，唯一键，普通键都可以成为索引。

### 不同数据结构对索引的效果

1：二叉查找树，时间成本为(logn)，但是每次深度增加1就会增加一次IO，所以效率不高。

2.：B-Tree：

![image-20211030161434601](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211030161434601.png)



![image-20211030161510049](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211030161510049.png)

![image-20211030162304509](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211030162304509.png)

B树和二叉查找树效率一样，都是logn

### B+树

类似B树，但是非叶子节点的子树指针与关键字个数相同。并且只在叶子结点里保存数据，非叶子节点只是用来做索引。叶子节点有一个指针用来做非叶子节点

![image-20211030162734352](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211030162734352.png)

B+Tree比较适合做索引因为：

B+树的磁盘读写代价更低：因为非叶子节点没有指针，只有索引，所以一次可以读取更多的索引进行查找

而且查询效率非常稳定，每个数字查询效率都差不多，都需要从根节点查找到子节点。

B+树更有利于对数据库的扫描，特别是范围数据。

### Hash索引，Bitmap索引

Hash索引的问题是：只满足 = 不满足范围查询。

无法被用来避免数据的排序操作

不能利用组合索引查询

不能避免表扫描。

遇到大量Hash值相等的情况以后，性能并不高



Bitmap：

![image-20211030164543990](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211030164543990-16355835442231.png)

锁开销非常的大,因为同时锁住了好多行的数据

## 密集索引和稀疏索引的区别

密集索引文件中的每个搜索码值都对应一个索引值，稀疏索引只为索引码的某些值建立索引项。

![image-20211030165434084](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211030165434084.png)

*- 稠密索引比稀疏索引更快的定位一条记录。*
*- 稀疏索引所占空间小，并且插入和删除时所需维护的开销也小。*

![image-20211030165603409](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211030165603409.png)

## SQL慢查询优化

![image-20211031102550413](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211031102550413.png)

Explain关键字段

![image-20211031104359014](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211031104359014.png)

![image-20211031104441749](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211031104441749.png)

## 联合索引的最左匹配原则

![image-20211031110715049](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211031110715049.png)

联合索引数据结构：

按照索引排序以后，保证第一个是按顺序排列的，然后再按照第二列排序，所以才会有最左匹配原则



## 索引越多越好么

数据量小的表格不需要建立索引，建立索引会增加额外的索引开销

数据变更需要维护索引，更多的索引代表着更多的维护成本

更多的索引意味着需要更多的空间



## 事务四大特性：ACID

原子性：事务是最小的执行单位，不允许分割。要么全部完成要么全部回滚

一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。

隔离性：并发访问数据库时，一个失误不被其他事物干扰。

持久性：一个失误被提交之后，他对数据库中的数据改变是持久的。

## 并发引起的问题

1. 更新丢失：一个事务的更新覆盖了另外一个事务的更新
2. 脏读：一个事务正在修改数据，另一个事务读了这个数据。
3. 不可重复读：读同一个数据发现读的结果不一样，因为其他线程在两次读操作之间更改了数据。
4. 幻读：类似不可重复度，区别是发生在多行数据读取，第一次读取某些数据，第二次读取发现数据变多或者变少了，因为其他县城在两次读操作之间添加或者删除了数据。

## 事务隔离级别

READ-UNCOMMITTED:允许读取没有提交的数据变更。

READ-COMMITTED:允许读取并发事务已经提交的数据，可以阻止脏读。

REPEATABLE-READ:默认级别，同一行字段的多次读取结果是一致的，除非数据是被事务自己修改了。不能阻止幻读发生

SERIALIZABLE:事务变成单线程操作，一个一个执行。

## InnoDB 在REPEATABLE-READ下为什么可以实现避免幻读

快照读：在InnoDB中，开启事务之后select会使用快照读而不是当前读。就算修改了数据也不会出现幻读。

真正原因：next-key锁：

nextkey = 行锁+Gap锁（范围锁），Gap锁只存在于RR级别下.



## 三大范式

1.第一范式（1NF）:列不可再分

2.第二范式（2NF）属性完全依赖于主键

3.第三范式（3NF）属性不依赖于其它非主属性    属性直接依赖于主键









# 计算机网络

## HTTP全过程

![image-20211105125529735](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211105125529735.png)



# Spring

## Bean生命周期

![image-20211105132022280](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211105132022280.png)

1、实例化bean对象
通过反射的方式进行对象的创建，此时的创建只是在堆空间中申请空间，属性都是默认值
2、设置对象属性
给对象中的属性进行值的设置工作
3、检查Aware相关接口并设置相关依赖
如果对象中需要引用容器内部的对象，那么需要调用aware接口的子类方法来进行统一的设置
4、BeanPostProcessor的前置处理
对生成的bean对象进行前置的处理工作
5、检查是否是InitializingBean的子类来决定是否调用afterPropertiesSet方法
判断当前bean对象是否设置了InitializingBean接口，然后进行属性的设置等基本工作
6、检查是否配置有自定义的init-method方法
如果当前bean对象定义了初始化方法，那么在此处调用初始化方法

  7、BeanPostProcessor后置处理
对生成的bean对象进行后置的处理工作
8、注册必要的Destruction相关回调接口
为了方便对象的销毁，在此处调用注销的回调接口，方便对象进行销毁操作
9、获取并使用bean对象
通过容器来获取对象并进行使用
10、是否实现DisposableBean接口
判断是否实现了DisposableBean接口，并调用具体的方法来进行对象的销毁工作
11、是否配置有自定义的destory方法
如果当前bean对象定义了销毁方法，那么在此处调用销毁方法

## SpringMVC工作原理

![image-20211105131134676](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211105131134676.png)



## Spring事务传播行为

![image-20211105131320624](C:\Users\Wang\OneDrive\Java全家桶\重点知识汇总.assets\image-20211105131320624.png)

## @ControllerAdvice和@ExceptionHandler实现全局异常处理



## spring支持的bean作用域有哪些？

① singleton
使用该属性定义Bean时，IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。
② prototype
使用该属性定义Bean时，IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例。
③ request
该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适
用于WebApplicationContext环境。
④ session
该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。
⑤ global-session
该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。



